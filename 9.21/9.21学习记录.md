# :date:9.21学习记录

# :tomato:TODO

- [x] GO语言核心编程
- [ ] GO语言进阶设计
- [ ] 网络
- [ ] 系统
- [ ] MySQL
- [ ] Redis
- [ ] 投递简历

# :o:GO核心编程

## :package: 函数使用细节

- go语言中，函数也是一种数据类型，可以赋值给一个变量

![image-20210921122209995](https://gitee.com/loloxwg/picture/raw/master/202109211222086.png)



- 函数可以作为形参，并且调用

  ![image-20210921122321924](https://gitee.com/loloxwg/picture/raw/master/202109211223970.png)

- go支持可变参数

  ![image-20210921122427611](https://gitee.com/loloxwg/picture/raw/master/202109211224664.png)

  ![image-20210921122454755](https://gitee.com/loloxwg/picture/raw/master/202109211224813.png)

- 例子

  ![image-20210921124131925](https://gitee.com/loloxwg/picture/raw/master/202109211241018.png)

## :package: init函数

### init() 在main()之前执行

`main.go`

```go
package main
import (
	"fmt"
	//引入包
	"go_code/chapter06/funcinit/utils"
)

var age = test()

//为了看到全局变量是先被初始化的，我们这里先写函数
func test() int {
	fmt.Println("test()") //1
	return 90
}

//init函数,通常可以在init函数中完成初始化工作
func init() {
	fmt.Println("init()...") //2
}

func main() {
	fmt.Println("main()...age=", age) //3
	fmt.Println("Age=", utils.Age, "Name=", utils.Name)

}
```
 `utils.go`
```go
package utils
import "fmt"
var Age int
var Name string

//Age 和 Name 全局变量，我们需要在main.go 使用
//但是我们需要初始化Age 和 Name

//init 函数完成初始化工作
func init() {
	fmt.Println("utils 包的  init()...")
	Age = 100
	Name = "tom~"
}
```

![image-20210921131040052](https://gitee.com/loloxwg/picture/raw/master/202109211310130.png)

### init函数注意事项

![image-20210921131252550](https://gitee.com/loloxwg/picture/raw/master/202109211312617.png)

导包———->全局变量—–>init()————->main()



##:package: 匿名函数

- 在定义匿名函数时就直接调用，这种方式匿名函数只能调用一次
- 函数变量匿名函数
- 全局匿名函数

```go
package main
import (
   "fmt"
)

var (
   //fun1就是一个全局匿名函数
   Fun1 = func (n1 int, n2 int) int {
      return n1 * n2
   }
)

func main() {
   //在定义匿名函数时就直接调用，这种方式匿名函数只能调用一次

   //案例演示,求两个数的和， 使用匿名函数的方式完成
   res1 := func (n1 int, n2 int) int {
      return n1 + n2
   }(10, 20)

   fmt.Println("res1=", res1)

   //将匿名函数func (n1 int, n2 int) int赋给 a变量
   //则a 的数据类型就是函数类型 ，此时,我们可以通过a完成调用
   a := func (n1 int, n2 int) int {
      return n1 - n2
   }

   res2 := a(10, 30)
   fmt.Println("res2=", res2)
   res3 := a(90, 30)
   fmt.Println("res3=", res3)

   //全局匿名函数的使用
   res4 := Fun1(4, 9)
   fmt.Println("res4=", res4)
}
```

## :package: 闭包

一个函数与想引用的环境（变量）组成的整体

闭包和匿名函数密不可分

匿名函数和引用的外部变量构成一个闭包

###:point_right: 闭包的优势

比普通函数传参少

闭包可以保留上次引用的值，传入一次，反复使用

比用全局变量好用

```go
package main
import (
   "fmt"
   "strings"
)


//累加器
func AddUpper() func (int) int {
   var n int = 10 
   var str = "hello"
   return func (x int) int {
      n = n + x
      str += string(36) // => 36 = '$'   
      fmt.Println("str=", str) // 1. str="hello$" 2. str="hello$$" 3. str="hello$$$"
      return n
   }
}

//
// 1)编写一个函数 makeSuffix(suffix string)  可以接收一个文件后缀名(比如.jpg)，并返回一个闭包
// 2)调用闭包，可以传入一个文件名，如果该文件名没有指定的后缀(比如.jpg) ,则返回 文件名.jpg , 如果已经有.jpg后缀，则返回原文件名。
// 3)要求使用闭包的方式完成
// 4)strings.HasSuffix , 该函数可以判断某个字符串是否有指定的后缀。

func makeSuffix(suffix string) func (string) string {

   return func (name string) string {
      //如果 name 没有指定后缀，则加上，否则就返回原来的名字
      if !strings.HasSuffix(name, suffix)  {
         return name + suffix
      }

      return name
   }
}


func makeSuffix2(suffix string, name string)  string {


   //如果 name 没有指定后缀，则加上，否则就返回原来的名字
   if !strings.HasSuffix(name, suffix)  {
      return name + suffix
   }

   return name
   
}

func main() {
   
   //使用前面的代码
   f := AddUpper()
   fmt.Println(f(1))// 11 
   fmt.Println(f(2))// 13
   fmt.Println(f(3))// 16


   //测试makeSuffix 的使用
   //返回一个闭包
   f2 := makeSuffix(".jpg") //如果使用闭包完成，好处是只需要传入一次后缀。
   fmt.Println("文件名处理后=", f2("winter")) // winter.jgp
   fmt.Println("文件名处理后=", f2("bird.jpg")) // bird.jpg

   fmt.Println("文件名处理后=", makeSuffix2("jpg", "winter")) // winter.jgp
   fmt.Println("文件名处理后=", makeSuffix2("jpg", "bird.jpg")) // bird.jpg



}
```

## :package: defer

在函数中，程序员创建资源（数据库连接，文件句柄，锁），在函数执行完毕后，及时释放资源，使用的延时机制

```
当执行到defer时，会将defer后面的语句压入到独立的栈中(defer栈)
当函数执行完毕以后，在从defer栈，按照先入后出的方式出栈
```



```go
package main
import (
   "fmt"
)

func sum(n1 int, n2 int) int {
   
   //当执行到defer时，暂时不执行，会将defer后面的语句压入到独立的栈(defer栈)
   //当函数执行完毕后，再从defer栈，按照先入后出的方式出栈，执行
   defer fmt.Println("ok1 n1=", n1) //defer 3. ok1 n1 = 10
   defer fmt.Println("ok2 n2=", n2) //defer 2. ok2 n2= 20
   //增加一句话
   n1++ // n1 = 11
   n2++ // n2 = 21
   res := n1 + n2 // res = 32
   fmt.Println("ok3 res=", res) // 1. ok3 res= 32
   return res

}

func main() {
   res := sum(10, 20)
   fmt.Println("res=", res)  // 4. res= 32
}
   
```

### defer注意事项

![image-20210921161600311](https://gitee.com/loloxwg/picture/raw/master/202109211616382.png)

![image-20210921161631813](https://gitee.com/loloxwg/picture/raw/master/202109211616846.png)

### :point_right: defer 应用

![image-20210921162201119](https://gitee.com/loloxwg/picture/raw/master/202109211622178.png)

![image-20210921162348290](https://gitee.com/loloxwg/picture/raw/master/202109211623331.png)

## :package:函数参数的传递方式

### 两种传递

- 值传递 int float系列, bool ,数组，结构体struct
- 引用传递 指针 ，slice ，map ,chan , interface

![image-20210921163804336](https://gitee.com/loloxwg/picture/raw/master/202109211638385.png)

### :point_right: 注意事项

值类型默认值传递

引用类型默认引用传递

![image-20210921164021625](https://gitee.com/loloxwg/picture/raw/master/202109211640717.png)

# :package:map



