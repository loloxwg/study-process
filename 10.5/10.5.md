# 10.5

- [ ]  çœ‹å®Œäº†goä¸“å®¶ç¼–ç¨‹
- [ ] contextç”¨æ¥åä½œå¤šä¸ªgoroutine,é€šçŸ¥ä»–ä»¬åœæ­¢
- [ ] å°åº¦äººçš„BLOGè®²çš„context

# Factory patterns in Go (Golang) ğŸ­

- [ ] æ¥å£å·¥å‚æ¨¡å¼
- [ ] æ··åˆå·¥å‚æ¨¡å¼
- [ ] æ–¹æ³•å·¥å‚æ¨¡å¼

# Using Context in Golang - Cancellation, Timeouts and Values (With Examples)

## When Do We Use Context?

As the name suggests, we use the context package whenever we want to pass around â€œcontextâ€, or *common scoped data* within our application. For example:

- Request IDs for function calls and goroutines that are part of an HTTP request call
- Errors when fetching data from a database
- Cancellation signals whe performing async operations using goroutines

![context refers to common scoped data within goroutines or function calls](https://www.sohamkamani.com/1005523fd11d74bd03fef5564e999eaf/context-in-practice.svg)

Using the [Context](https://pkg.go.dev/context#Context) data type is the idiomatic way to pass information across these kind of operations, such as:

1. Cancellation signals to terminate the operation
2. Miscellaneous data required at every function call invoked by the operation

Letâ€™s talk about cancellation first:

## Why Do We Need Cancellation?

In short, we need cancellation to prevent our system from doing unnecessary work.

Consider the common situation of an HTTP server making a call to a database, and returning the queried data to the client:

![client server model diagram](https://www.sohamkamani.com/199c2b8faf7663c9b7e83de127012a6c/client-diagram.svg)

The timing diagram, if everything worked perfectly, would look like this:

![timing diagram with all events finishing](https://www.sohamkamani.com/ff6e4d831668b9da81c1c214224e4521/timing-ideal.svg)

But, what would happen if the client cancelled the request in the middle? This could happen if, for example, the client closed their browser mid-request.

Without cancellation, the application server and database would continue to do their work, even though the result of that work would be wasted:

![timing diagram with http request cancelled, and other processes still taking place](https://www.sohamkamani.com/4955e194034f42b5edd7632f1461c124/timing-without-cancel.svg)

Ideally, we would want all downstream components of a process to halt, if we *know* that the process (in this example, the HTTP request) halted:

![timing diagram with all processes cancelling once HTTP request is cancelled](https://www.sohamkamani.com/2af484f735aab3022ea8d7a9a9c1b675/timing-with-cancel.svg)

# åå°„

##  ç‰¹æ®Šçš„interfaceç±»å‹

æœ€ç‰¹æ®Šçš„interfaceç±»å‹ä¸ºç©ºinterfaceç±»å‹ï¼Œå³`interface {}`ï¼Œå‰é¢è¯´äº†ï¼Œinterfaceç”¨æ¥è¡¨ç¤ºä¸€ç»„æ–¹æ³•é›†åˆï¼Œæ‰€æœ‰å®ç°è¯¥æ–¹æ³•é›†åˆçš„ç±»å‹éƒ½è¢«è®¤ä¸ºæ˜¯å®ç°äº†è¯¥æ¥å£ã€‚é‚£ä¹ˆç©ºinterfaceç±»å‹çš„æ–¹æ³•é›†åˆä¸ºç©ºï¼Œä¹Ÿå°±æ˜¯è¯´æ‰€æœ‰ç±»å‹éƒ½å¯ä»¥è®¤ä¸ºæ˜¯å®ç°äº†è¯¥æ¥å£ã€‚

ä¸€ä¸ªç±»å‹å®ç°ç©ºinterfaceå¹¶ä¸é‡è¦ï¼Œé‡è¦çš„æ˜¯ä¸€ä¸ªç©ºinterfaceç±»å‹å˜é‡å¯ä»¥å­˜æ”¾æ‰€æœ‰å€¼ï¼Œè®°ä½æ˜¯æ‰€æœ‰å€¼ï¼Œè¿™æ‰æ˜¯æœ€æœ€é‡è¦çš„ã€‚ è¿™ä¹Ÿæ˜¯æœ‰äº›äººè®¤ä¸ºGoæ˜¯åŠ¨æ€ç±»å‹çš„åŸå› ï¼Œè¿™æ˜¯ä¸ªé”™è§‰ã€‚

## interfaceç±»å‹æ˜¯å¦‚ä½•è¡¨ç¤ºçš„

å‰é¢è®²äº†ï¼Œinterfaceç±»å‹çš„å˜é‡å¯ä»¥å­˜æ”¾ä»»ä½•å®ç°äº†è¯¥æ¥å£çš„å€¼ã€‚è¿˜æ˜¯ä»¥ä¸Šé¢çš„`io.Reader`ä¸ºä¾‹è¿›è¡Œè¯´æ˜ï¼Œ`io.Reader`æ˜¯ä¸€ä¸ªæ¥å£ç±»å‹ï¼Œ`os.OpenFile()`æ–¹æ³•è¿”å›ä¸€ä¸ª`File`ç»“æ„ä½“ç±»å‹å˜é‡ï¼Œè¯¥ç»“æ„ä½“ç±»å‹å®ç°äº†`io.Reader`çš„æ–¹æ³•ï¼Œé‚£ä¹ˆ`io.Reader`ç±»å‹å˜é‡å°±å¯ä»¥ç”¨æ¥æ¥æ”¶è¯¥è¿”å›å€¼ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
var r io.Reader
tty, err := os.OpenFile("/dev/tty", os.O_RDWR, 0)
if err != nil {
    return nil, err
}
r = tty
```

é‚£ä¹ˆé—®é¢˜æ¥äº†ã€‚
Qï¼š rçš„ç±»å‹æ˜¯ä»€ä¹ˆï¼Ÿ
A: rçš„ç±»å‹å§‹ç»ˆæ˜¯`io.Reader`interfaceç±»å‹ï¼Œæ— è®ºå…¶å­˜å‚¨ä»€ä¹ˆå€¼ã€‚

Qï¼šé‚£`File`ç±»å‹ä½“ç°åœ¨å“ªé‡Œï¼Ÿ
Aï¼šrä¿å­˜äº†ä¸€ä¸ª(value, type)å¯¹æ¥è¡¨ç¤ºå…¶æ‰€å­˜å‚¨å€¼çš„ä¿¡æ¯ã€‚ valueå³ä¸ºræ‰€æŒæœ‰å…ƒç´ çš„å€¼ï¼Œtypeå³ä¸ºæ‰€æŒæœ‰å…ƒç´ çš„åº•å±‚ç±»å‹

Qï¼šå¦‚ä½•å°†rè½¬æ¢æˆå¦ä¸€ä¸ªç±»å‹ç»“æ„ä½“å˜é‡ï¼Ÿæ¯”å¦‚è½¬æ¢æˆ`io.Writer`
Aï¼šä½¿ç”¨ç±»å‹æ–­è¨€ï¼Œå¦‚`w = r.(io.Writer)`. **æ„æ€æ˜¯å¦‚æœræ‰€æŒæœ‰çš„å…ƒç´ å¦‚æœåŒæ ·å®ç°äº†io.Writeræ¥å£,é‚£ä¹ˆå°±æŠŠå€¼ä¼ é€’ç»™wã€‚**

# åå°„ä¸‰å®šå¾‹

å‰é¢ä¹‹æ‰€ä»¥è®²ç±»å‹ï¼Œæ˜¯ä¸ºäº†å¼•å‡ºinterfaceï¼Œä¹‹æ‰€ä»¥è®²interfaceæ˜¯æƒ³è¯´interfaceç±»å‹æœ‰ä¸ª(valueï¼Œtype)å¯¹ï¼Œè€Œåå°„å°±æ˜¯æ£€æŸ¥interfaceçš„è¿™ä¸ª(value, type)å¯¹çš„ã€‚å…·ä½“ä¸€ç‚¹è¯´å°±æ˜¯Goæä¾›ä¸€ç»„æ–¹æ³•æå–interfaceçš„valueï¼Œæä¾›å¦ä¸€ç»„æ–¹æ³•æå–interfaceçš„type.

å®˜æ–¹æä¾›äº†ä¸‰æ¡å®šå¾‹æ¥è¯´æ˜åå°„ï¼Œæ¯”è¾ƒæ¸…æ™°ï¼Œä¸‹é¢ä¹ŸæŒ‰ç…§è¿™ä¸‰å®šå¾‹æ¥æ€»ç»“ã€‚

åå°„åŒ…é‡Œæœ‰ä¸¤ä¸ªæ¥å£ç±»å‹è¦å…ˆäº†è§£ä¸€ä¸‹.

- `reflect.Type` æä¾›ä¸€ç»„æ¥å£å¤„ç†interfaceçš„ç±»å‹ï¼Œå³ï¼ˆvalue, typeï¼‰ä¸­çš„type
- `reflect.Value`æä¾›ä¸€ç»„æ¥å£å¤„ç†interfaceçš„å€¼,å³(value, type)ä¸­çš„value

ä¸‹é¢ä¼šæåˆ°åå°„å¯¹è±¡ï¼Œæ‰€è°“åå°„å¯¹è±¡å³åå°„åŒ…é‡Œæä¾›çš„ä¸¤ç§ç±»å‹çš„å¯¹è±¡ã€‚

- `reflect.Type` ç±»å‹å¯¹è±¡
- `reflect.Value`ç±»å‹å¯¹è±¡

## 3.1 åå°„ç¬¬ä¸€å®šå¾‹ï¼šåå°„å¯ä»¥å°†interfaceç±»å‹å˜é‡è½¬æ¢æˆåå°„å¯¹è±¡

ä¸‹é¢ç¤ºä¾‹ï¼Œçœ‹çœ‹æ˜¯å¦‚ä½•é€šè¿‡åå°„è·å–ä¸€ä¸ªå˜é‡çš„å€¼å’Œç±»å‹çš„ï¼š

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x float64 = 3.4
    t := reflect.TypeOf(x)  //t is reflect.Type
    fmt.Println("type:", t)

    v := reflect.ValueOf(x) //v is reflect.Value
    fmt.Println("value:", v)
}
```

ç¨‹åºè¾“å‡ºå¦‚ä¸‹ï¼š

```go
type: float64
value: 3.4
```

æ³¨æ„ï¼šåå°„æ˜¯é’ˆå¯¹interfaceç±»å‹å˜é‡çš„ï¼Œå…¶ä¸­`TypeOf()`å’Œ`ValueOf()`æ¥å—çš„å‚æ•°éƒ½æ˜¯`interface{}`ç±»å‹çš„ï¼Œä¹Ÿå³xå€¼æ˜¯è¢«è½¬æˆäº†interfaceä¼ å…¥çš„ã€‚

é™¤äº†`reflect.TypeOf()`å’Œ`reflect.ValueOf()`ï¼Œè¿˜æœ‰å…¶ä»–å¾ˆå¤šæ–¹æ³•å¯ä»¥æ“ä½œï¼Œæœ¬æ–‡å…ˆä¸è¿‡å¤šä»‹ç»ï¼Œå¦åˆ™ä¸€ä¸å°å¿ƒä¼šä¼šå¼•èµ·å›°æƒ‘ã€‚

## 3.2 åå°„ç¬¬äºŒå®šå¾‹ï¼šåå°„å¯ä»¥å°†åå°„å¯¹è±¡è¿˜åŸæˆinterfaceå¯¹è±¡

ä¹‹æ‰€ä»¥å«â€™åå°„â€™ï¼Œåå°„å¯¹è±¡ä¸interfaceå¯¹è±¡æ˜¯å¯ä»¥äº’ç›¸è½¬åŒ–çš„ã€‚çœ‹ä»¥ä¸‹ä¾‹å­ï¼š

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x float64 = 3.4

    v := reflect.ValueOf(x) //v is reflect.Value

    var y float64 = v.Interface().(float64)
    fmt.Println("value:", y)
}
```

å¯¹è±¡xè½¬æ¢æˆåå°„å¯¹è±¡vï¼Œvåˆé€šè¿‡Interface()æ¥å£è½¬æ¢æˆinterfaceå¯¹è±¡ï¼Œinterfaceå¯¹è±¡é€šè¿‡.(float64)ç±»å‹æ–­è¨€è·å–float64ç±»å‹çš„å€¼ã€‚

## 3.3 åå°„ç¬¬ä¸‰å®šå¾‹ï¼šåå°„å¯¹è±¡å¯ä¿®æ”¹ï¼Œvalueå€¼å¿…é¡»æ˜¯å¯è®¾ç½®çš„

é€šè¿‡åå°„å¯ä»¥å°†interfaceç±»å‹å˜é‡è½¬æ¢æˆåå°„å¯¹è±¡ï¼Œå¯ä»¥ä½¿ç”¨è¯¥åå°„å¯¹è±¡è®¾ç½®å…¶æŒæœ‰çš„å€¼ã€‚åœ¨ä»‹ç»ä½•è°“åå°„å¯¹è±¡å¯ä¿®æ”¹å‰ï¼Œå…ˆçœ‹ä¸€ä¸‹å¤±è´¥çš„ä¾‹å­ï¼š

```go
package main

import (
    "reflect"
)

func main() {
    var x float64 = 3.4
    v := reflect.ValueOf(x)
    v.SetFloat(7.1) // Error: will panic.
}
```

å¦‚ä¸‹ä»£ç ï¼Œé€šè¿‡åå°„å¯¹è±¡vè®¾ç½®æ–°å€¼ï¼Œä¼šå‡ºç°panicã€‚æŠ¥é”™å¦‚ä¸‹ï¼š

```go
panic: reflect: reflect.Value.SetFloat using unaddressable value
```

é”™è¯¯åŸå› å³æ˜¯væ˜¯ä¸å¯ä¿®æ”¹çš„ã€‚

åå°„å¯¹è±¡æ˜¯å¦å¯ä¿®æ”¹å–å†³äºå…¶æ‰€å­˜å‚¨çš„å€¼ï¼Œå›æƒ³ä¸€ä¸‹å‡½æ•°ä¼ å‚æ—¶æ˜¯ä¼ å€¼è¿˜æ˜¯ä¼ å€å°±ä¸éš¾ç†è§£ä¸Šä¾‹ä¸­ä¸ºä½•å¤±è´¥äº†ã€‚

ä¸Šä¾‹ä¸­ï¼Œä¼ å…¥reflect.ValueOf()å‡½æ•°çš„å…¶å®æ˜¯xçš„å€¼ï¼Œè€Œéxæœ¬èº«ã€‚å³é€šè¿‡vä¿®æ”¹å…¶å€¼æ˜¯æ— æ³•å½±å“xçš„ï¼Œä¹Ÿå³æ˜¯æ— æ•ˆçš„ä¿®æ”¹ï¼Œæ‰€ä»¥golangä¼šæŠ¥é”™ã€‚

æƒ³åˆ°æ­¤å¤„ï¼Œå³å¯æ˜ç™½ï¼Œå¦‚æœæ„å»ºvæ—¶ä½¿ç”¨xçš„åœ°å€å°±å¯å®ç°ä¿®æ”¹äº†ï¼Œä½†æ­¤æ—¶vä»£è¡¨çš„æ˜¯æŒ‡é’ˆåœ°å€ï¼Œæˆ‘ä»¬è¦è®¾ç½®çš„æ˜¯æŒ‡é’ˆæ‰€æŒ‡å‘çš„å†…å®¹ï¼Œä¹Ÿå³æˆ‘ä»¬æƒ³è¦ä¿®æ”¹çš„æ˜¯`*v`ã€‚ é‚£æ€ä¹ˆé€šè¿‡vä¿®æ”¹xçš„å€¼å‘¢ï¼Ÿ

`reflect.Value`æä¾›äº†`Elem()`æ–¹æ³•ï¼Œå¯ä»¥è·å¾—æŒ‡é’ˆå‘æŒ‡å‘çš„`value`ã€‚çœ‹å¦‚ä¸‹ä»£ç ï¼š

```go
package main

import (
"reflect"
    "fmt"
)

func main() {
    var x float64 = 3.4
    v := reflect.ValueOf(&x)
    v.Elem().SetFloat(7.1)
    fmt.Println("x :", v.Elem().Interface())
}
```

è¾“å‡ºä¸ºï¼š

```go
x : 7.1
```